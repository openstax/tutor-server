require_relative 'base'
require_relative 'config/course'

# Imports a book from CNX and creates a course with periods from it's data
class Demo::Courses < Demo::Base

  lev_routine

  disable_automatic_lev_transactions

  uses_routine CreateCourse, as: :create_course
  uses_routine CreatePeriod, as: :create_period
  uses_routine CourseMembership::UpdatePeriod, as: :update_period
  uses_routine AddEcosystemToCourse, as: :add_ecosystem
  uses_routine User::SetAdministratorState, as: :set_administrator
  uses_routine User::SetContentAnalystState, as: :set_content_analyst
  uses_routine User::SetCustomerServiceState, as: :set_customer_service
  uses_routine AddUserAsCourseTeacher, as: :add_teacher
  uses_routine AddUserAsPeriodStudent, as: :add_student
  uses_routine UserIsCourseStudent, as: :is_student
  uses_routine UserIsCourseTeacher, as: :is_teacher

  protected

  def exec(config: :all, random_seed: nil)
    # Choose a fixed seed for repeatability and fewer surprises
    set_random_seed(random_seed)

    # Parallel step
    in_parallel(Demo::Config::Course[config], transaction: true) do |course_configs, idx_start|
      course_configs.each do |course_config|
        offering = find_catalog_offering_by_salesforce_book_name course_config.salesforce_book_name
        course = create_course(name: course_config.course_name,
                               term: CourseProfile::Models::Course.terms[:demo],
                               year: Time.current.year,
                               catalog_offering: offering,
                               is_college: course_config.is_college)

        log { "Course: #{course.name} (id: #{course.id})" }

        course_config.teachers.each do |username|
          configure_course_teacher(course, username)
        end

        course_config.periods.each_with_index do |period_config, index|
          configure_course_period(course, period_config, index)
        end

        course_config.id = course.id
      end # course_config
    end # process

    wait_for_parallel_completion
  end

  def create_course(name:, term:, year:, catalog_offering:, is_college:,
                    starts_at: nil, ends_at: nil, appearance_code: nil, school: nil, time_zone: nil)
    run(:create_course,
        name: name,
        term: term,
        year: year,
        catalog_offering: catalog_offering,
        is_college: is_college,
        is_preview: false,
        is_test: true,
        starts_at: starts_at,
        ends_at: ends_at,
        appearance_code: appearance_code,
        school: school,
        time_zone: time_zone).outputs.course.tap do |course|
      log { "Created a course named '#{name}'." }
    end
  end

  def find_or_create_period(course:, name:)
    CourseMembership::Models::Period.find_by(course: course, name: name) ||
    run(:create_period, course: course, name: name).outputs.period.to_model
  end

  def configure_course_teacher(course, username)
    name = teachers[username]

    raise "Unable to find teacher for #{username}" if name.nil?

    teacher_user = find_or_create_user_by_username(
      username,
      name: name,
      faculty_status: :confirmed_faculty
    )

    log { "Teacher: #{username} (#{name})" }

    unless run(:is_teacher, user: teacher_user, course: course).outputs.user_is_course_teacher
      run(:add_teacher, course: course, user: teacher_user)
    end
  end

  def configure_course_period(course, period_config, index)
    period_name = period_config.name
    period = find_or_create_period(course: course, name: period_name)

    log { "  Period: #{period_config.name}" }

    if period_config.enrollment_code
      run(:update_period, period: period, enrollment_code: period_config.enrollment_code)
    end

    (period_config.students || []).each do |username|
      name = students[username]

      raise "Unable to find student for #{username}" if name.nil?

      user = find_or_create_user_by_username(username, name: name)
      student_identifier = SecureRandom.urlsafe_base64(10)

      log { "    #{username} (#{name})" }

      run(:add_student, period: period, user: user, student_identifier: student_identifier) \
        unless run(:is_student, user: user, course: course,
                                include_dropped_students: true).outputs.user_is_course_student
    end

    (period_config.auto_students || 0).times do |sindex|
      name = Faker::Name.name
      username = "#{name.downcase} #{index + 1} #{sindex + 1}".gsub(/[\s.]+/, '_')
      user = new_user(username: username, name: name)

      log { "    Autogenerated #{username} (#{name})" }

      run(:add_student, period: period, user: user)
    end
  end
end
