require_relative 'base'

## Imports a book from CNX and creates a course with periods from it's data
class Demo::Content < Demo::Base

  lev_routine

  disable_automatic_lev_transactions

  uses_routine FetchAndImportBookAndCreateEcosystem, as: :import_book
  uses_routine CreateCourse, as: :create_course
  uses_routine CreatePeriod, as: :create_period
  uses_routine CourseMembership::UpdatePeriod, as: :update_period
  uses_routine AddEcosystemToCourse, as: :add_ecosystem
  uses_routine User::SetAdministratorState, as: :set_administrator
  uses_routine User::SetContentAnalystState, as: :set_content_analyst
  uses_routine User::SetCustomerServiceState, as: :set_customer_service
  uses_routine AddUserAsCourseTeacher, as: :add_teacher
  uses_routine AddUserAsPeriodStudent, as: :add_student
  uses_routine UserIsCourseStudent, as: :is_student
  uses_routine UserIsCourseTeacher, as: :is_teacher
  uses_routine CourseProfile::SetCatalogOffering, as: :set_offering

  protected

  def setup_staff_user_accounts
    admin_user = user_for_username('admin') || new_user(username: 'admin', name: people.admin)
    run(:set_administrator, user: admin_user, administrator: true)
    run(:set_content_analyst, user: admin_user, content_analyst: true)
    run(:set_customer_service, user: admin_user, customer_service: true)
    log("Admin user: #{admin_user.name}")

    ca_user = user_for_username('content') ||
              new_user(username: 'content', name: people.content_analyst)
    run(:set_content_analyst, user: ca_user, content_analyst: true)
    log("Content Analyst user: #{ca_user.name}")

    cs_user = user_for_username('customer') ||
              new_user(username: 'customer', name: people.customer_service)
    run(:set_customer_service, user: cs_user, customer_service: true)
    log("Customer Service user: #{cs_user.name}")

    new_zz_users = (0..99).map do |ii|
      username = "zz_#{ii.to_s.rjust(2, "0")}"
      next if user_for_username(username)
      new_user(username: username, name: username.gsub('_', ' '))
    end.compact
    log("Made #{new_zz_users.size} extra 'zz' users who are not in any course.") \
      unless new_zz_users.empty?
  end

  def configure_course_teacher(course, teacher)
    teacher_user = get_teacher_user(teacher) ||
                   new_user(username: people.teachers[teacher].username,
                            name: people.teachers[teacher].name)
    log("Teacher: #{people.teachers[teacher].name}")
    unless run(:is_teacher, user: teacher_user, course: course).outputs.user_is_course_teacher
      run(:add_teacher, course: course, user: teacher_user)
    end
  end

  def configure_course_period(course, period_content, index)
    period_name = period_content.name
    period = find_period(course: course, name: period_name) || \
             run(:create_period, course: course, name: period_name).outputs.period
    log("  Period: #{period_content.name}")
    if period_content.enrollment_code
      run(:update_period, period: period, enrollment_code: period_content.enrollment_code)
    end

    (period_content.students || []).each do | initials |
      student_info = people.students[initials]
      user = get_student_user(initials) ||
             new_user(username: student_info.username, name: student_info.name)
      student_identifier = SecureRandom.urlsafe_base64(10)
      log("    #{initials} #{student_info.username} (#{student_info.name})")
      run(:add_student, period: period, user: user, student_identifier: student_identifier) \
        unless run(:is_student, user: user, course: course,
                                include_dropped: true).outputs.user_is_course_student

    end

    (period_content.auto_students || 0).times do |sindex|
      name = Faker::Name.name
      username = "#{name.downcase} #{index + 1} #{sindex + 1}".gsub(/[\s.]+/, '_')
      user = new_user(username: username, name: name)
      log("    Autogenerated #{username} (#{name})")
      run(:add_student, period: period, user: user)
    end
  end

  def configure_course(content)
     course = find_course(name: content.course_name) ||
              create_course(name: content.course_name,
                            starts_at: Time.current - 1.month,
                            ends_at: Time.current + 100.years,
                            appearance_code: content.appearance_code,
                            is_concept_coach: content.is_concept_coach,
                            is_college: content.is_college)

    log("Course: #{content.course_name}")

    content.teachers.each do |teacher|
      configure_course_teacher(course, teacher)
    end

    content.periods.each_with_index do | period_content, index |
      configure_course_period(course, period_content, index)
    end
    course
  end

  def exec(config: :all, print_logs: true, random_seed: nil, version: :defined)

    set_print_logs(print_logs)

    OpenStax::Exercises::V1.use_real_client
    configuration = OpenStax::Exercises::V1.configuration

    fatal_error(code: 'missing_openstax_exercises_tokens',
                message: 'Enter your OpenStax Exercises client_id and secret ' +
                         'in config/secrets.yml to use demo:content') \
      if !Rails.env.test? && (configuration.client_id.blank? || configuration.secret.blank?)

    # By default, choose a fixed seed for repeatability and fewer surprises
    set_random_seed(random_seed)

    # Serial step
    courses = []
    ActiveRecord::Base.transaction do
      setup_staff_user_accounts
      Demo::ContentConfiguration[config].each do | content |
        courses.push configure_course(content)
      end
    end

    # Parallel step
    in_parallel(Demo::ContentConfiguration[config], transaction: true) do |contents, idx_start|

      index = idx_start

      contents.each do | content |

        book = content.cnx_book(version)
        course = courses[index]
        log("Starting book import for #{course.name} from #{
            content.archive_url_base}#{book}")
        ecosystem = run(
          :import_book,
          book_cnx_id: book,
          archive_url: content.archive_url_base,
          reading_processing_instructions: content.reading_processing_instructions
        ).outputs.ecosystem

        log("Book import complete")
        run(:add_ecosystem, ecosystem: ecosystem, course: course)

        offering = find_or_create_catalog_offering(content, ecosystem)
        run(:set_offering, entity_course: course, catalog_offering: offering)

        index += 1

      end # book

    end # thread

    wait_for_parallel_completion

  end
end
